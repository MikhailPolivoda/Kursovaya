#include <iostream>
#include <cstdlib>
#include<vector>
#include<string>
#include<alghrithm>
using namespace std;

class Cashier :private Data_Input
{
public:
	Cashier(bool &free, int &id, int &time_end_service)
	{
		this->free = free;
		this->id = id;
		this->time_end_service = time_end_service;
	}
	
private:
	bool free;
	int id;
	double employment;
	int time_end_service;

};
class Client
{
public:
	Client(int &id,int &time_service_end,int &time_expectation, int &time_service)//время конца обслуживания нужно потом для вывода журнала событий
	{
		this->id = id;
		this->time_service = time_service;
		this->time_service_end = time_service_end;
		this->time_expectation = time_expectation;
	}
	Client(int& id, int& time_arrival,int &time_expectation)
	{
		this->id = id;
		this->time_arrival = time_arrival;
		this->time_expectation = time_expectation;
	}
	friend bool operator <(const Client& obj1, const Client& obj2);
protected:
	int id;//идентификатор клиента
	int time_service_end;//время конца обслуживания клиента
	int time_service;//время обслуживания
	int time_expectation;//время ожидания
	int time_arrival;//время прибытия

};
 bool operator <(const Client& obj1, const Client& obj2);
 {
	 return obj1.time_arrival < obj2.time_arrival;
 }
void modulation()
{
	int operating_time = 480;
	int number_of_employees = 5;
	int arrival_begin = 2;
	int arrival_end = 5;
	int service_begin = 2;
	int service_end = 5;
	int current_time = 0;
	int time_expectation=0;
	int id_client = 1;
	int id_worker = 1;
	int time_service = 0;
	int time_arrival = 0;//время прибытия
	int another_id = 0;//очередной id клиента по очереди
	vector<Client> queue;
	vector<Client> served_clients;
	vector<Cashier> workers_airport;

	for (int i = 1; i <= number_of_employees; i++)
	{
		workers_airport.push_back(1, i);
	}
	
	while (current_time < operating_time)
	{
		current_time += (arrival_begin + rand() % (arrival_end + 1);
		time_service = (service_begin + rand() % (service_end + 1);
		time_arrival = current_time;
		queue.push_back(id,time_arrival,0);

		for (auto& cashier : workers_airport)
		{
			if (cashier.time_service_end == current_time)//ищем свободных кассиров
			{
				cashier.free = 1;
			}
				if (cashier.free == 1)
				{
				
					cashier.employment += time_service;
						for (auto& qp : queue)
						{

							if (qp < (qp + 1))//cравниваем время прибытия, чем меньше время прибытия=>тем первее человек в очереди
							{
							another_id = qp.id;
							break;
							}

						time_expectation = qp.time_expectation;//время ожидания=времени ожидании клиента в очереди
						break;
						}

				cashier.time_service_end = time_service;//время окончания обслуживания кассира=времени обслуживания клиента
				served_clients.push_back(another_id, current_time + time_service, time_expectation, time_service);//добавляем клиента в вектор обслуженных клиентов
				queue.erase(queue.begin());//удаляем обслуженного клиента из очереди
				vector<Client>(queue).swap(queue);//освобождаем память из под удаленного элемента

				}

			if (cashier.free == 0) 
			{
				for (auto& qp : queue)
				{

					if (qp < (qp + 1))
					{
						qp.time_expectation += (cashier.time_service_end - current_time);//если кассир занят, то первому человеку в очереди присваиваем время ожидания 
						break;
					}
				
				}
				break;
			}
		id++;

	}
}
